<!DOCTYPE STFU/>
<html>
<head>
<title>STF: Standard Text Format STF8 & STF*
</title>
</head>
<body>
<font size=+2 color=royalblue>Two Bits, Two-Bit!</font>

<p>
<a name="two" />
<table border=10% width=100%><tr><td>
<font size="80%" color=#f7f >STF: Standard Text Format.</font>

<h1>
STF: Standard Text Format
</h1>
<h2>
STF is the most effective Means of Representation of all kinds of information. 
</h2>
<ul><li>
</li><li>
STF is the most simple, <b>effective</b>, and easy to comprehend way to accurately represent all knowledge and understanding!
</li><li>
<B>STF Books of Symbols</b> contain everything imaginable and you can make your own to represent anything inside!
</li><li>
Concepts are connected by Associative References 
</li><li>
STF: Standard Text Format has your TEXT as Symbols in STF BOOKs with WRAPs and Refinements and two simple things, a CUBE and a BALL, represented by Bits!
</li><li>
Everything gets a cube with a ball.
</li><li>
The CUBE has everything you need to accurately represent your concept, even the simple ones like symbols, graphemes, glyphs, and writing!
</li><li>
The BALL has everything you need to represent inter-associations of concepts, anywhere!
</li><li>
Implementation is simple, it's a WRAP!
</li></ul>
<H2>
Bits: (Leading High)
</H2>
<ul><li>
11: Alignment Expander for STF Symbols
</li><li>
10: STF Books of Symbols and Expander's Bits
</li><li>
01: Wraps, Named or Indexed Wraps, Symbol Refinements, CUBEs, Balls, References, Accurate Representations
</li><li>
00: Bits
</li></ul>

<h3>
The Wraps have Stuff. 
</h3>
<ul><li>
STF Standard WRAP Symbols in STF BOOKs
</li><li>
ON or OFF, Start and end of wrap.
</li><li>
Your WRAPs or CUBEs (or Symbols!), their Refinements, and their Connected Inclusions
</li><li>
Associated References, included or referenced by concepts
</li><li>
Turns & Slots, Parts & Holes
</li><li>
A CUBE & BALL for representation
</li><li>
The <b>STUFFER</b> that stuffs stuff.
</li></ul>

<!--
We don't know if It's either 01: {ON , OFF}{STF BOOK , Infrastructures:}{Your Wrap or Cube , Connected Inclusion} or 01: {CUBE , Inclusion}{ON , OFF}{STF BOOK , Infrastructure:} because on|off-book-?bbb matches bits but Cube|Inclusion-on|off-book-bbb is faster. Gain an Infrastructure bit by unstuffing the book to adjacent, gain some book bits and confusion into a tree, or wonder why the book has strange wraps not on|off. -->
<H3>
The Bits Inside:
</H3>
<ul><li><b>
01:1: YOUR STUFF! Your Text, Wrap or Cube, Concept References!
</li><li>
01:0: <small>Connected Inclusion!!!</small>
</li><li>
01:x1: Wrap or CUBE ON!
</li><li>
01:x0: Wrap or CUBE OFF!
</li><li>
01:xx:1 STF WRAP BOOK with Standard Wrap Symbols (or YOUR BOOK!)
</li><li>
01:xx:0 <small>Infrastructure</small>
</li><li></b>
<!--
or
</li><li>
01:1: Wrap ON!
</li><li>
01:0: Wrap OFF!
</li><li>
01:x1: STF BOOK
</li><li>
01:x0: Infrastructures
</li><li>
or
</li><li>
01:1: Wrap ON!
</li><li>
01:0: Wrap OFF!
</li><li>
01:x1: Stuff! Your Text, Wrap or Cube
</li><li>
01:x0: Connected Inclusion
</li><li>
01:xx:1 STF BOOK with Standard Symbols
</li><li>
01:xx:0 <small>Infrastructure
</li><li>
or
</li><li><b>
01:1: Wrap ON!
</li><li>
01:0: Wrap OFF!
</li><li>
01:x1: STF BOOK
</li><li>
01:x0: Infrastructures w/
</li><li>
01:xx:1 Text Wrap or Cube
</li><li>
01:xx:0 Connected Inclusion
</li><li></b>
...
</li><li>
01:1: STF BOOK (more bits)
</li><li>
01:0: Infrastructures
</li><li>
on,off?
</li><li>
... -->


<Small>
Infrastructure WRAPs:
<ul><li>
111: Import a Context Reference
</li><li>
110: Reference Anything + it's Associative Reference
</li><li>
101: Slots & Holes
</li><li>
100: Turns & Parts (Named Indexes & Refinements!)
</li><li>
011: Your new CUBE or Wrap, Inclusion's CUBE
</li><li>
010: Symbol Refinements, Inclusion's BALL
</li><li>
001: Accurate Representations, <b>STUFFER</b>
</li><li>
000: More <b>Stuff</b>! (adjacent)
</li><li>
</li></ul>
</Small>
</li></ul>
</li></ul>


<H3>
STF* Sizes:
</H3>
<ul><li>
4-Bit Educational
</li><li>
8-Bit Standard Text Format STF8
</li><li>
16-Bit Formalized STF16
</li><li>
Arbitrary Bit Scope &gt; 8 Bits
</li><li>
<small>Because the control channel is in the data channel, some use +2 more bits.</small>
</li></ul>

</td></tr></table>

<p>

<Hr>

<Small>

<p>
<a name="STF" />
<table border=10% width=100%><tr><td>
<font size="80%" >STF</font>
<h1>
STF: Standard Text Format
</h1>
<h3>
STF Completes the Unification of ALL Information.
</h3>
<hr>
<ul><li>
STF is the most <b>Effective</b> Means of Representation of Information, Concepts, Associatives, and Structured Knowledge.
</li><li>
STF: Standard Text Format consolidates all.
</li><li>
STF Accommodates all Text and Information, STF References with Associative Concepts, STF Universal Contexts and Accurate Means of Representation,  Wraps of ANY Complexity, and Connected Inclusions of Infrastructures.
</li><li>
STF includes Information packed in Expanders, <a href="#wrap">STF Wraps</a>, and Collections of Bits.
</li><li>
STF includes the arbitrary scope STF* and STF8 Standard.
</li></ul>
<h3>
<a href="#stf8">STF8: STF "8-Bit" Standard.</a>
</h3>
STF in [0i..7i] bit "8-bit" Blocks.
<h3>
<a href="#stf*">STF*: STF Arbitrary Standard.</a> 
</h3>
STF in Arbitrary Bit-Scope Blocks.
<h3>
<a href="#stf0">STF0: STF for Antiquated IRI (URI, URL, HTTP, etc.)</a>
</h3>

</td></tr><tr><td>
<ul><li>
STF: Standard Text Format facilitates accumulating all symbols into Books:
<a href="#complete" >Completeness</a>
</li><li>
STF Standard Implementations are logically perfect. STF requires only the Get & Set of Bits! 
</li><li>
<a href="#impl" >Implementation</a>
</li></ul>
</td></tr></table>

<p>

<a name="effect"/>
<table border=10% width=100%><tr><td>
<h1>
STF is Effective
</h1>
<ul><li>
STF is the most effective Means of Representation of all kinds of information. 
</li><li>
STF: Standard Text Format consolidates into Books of STF Symbols and Refinements for use in any Text or Presentation.
</li></ul>
<h2>
STF is Easy to Comprehend
</h2>
<ul><li>
A CUBE AND A BALL!
</li><li>
Turns in one hand, Slots in the other.
</li><li>
Wraps like cupped hands.
</li><li>
One standard.
</li><li>
Some Bits.
</li></ul>
<h2>
STF is Simple
</h2>
<ul><li>
STF Standard is the most simple way to correctly hold all information.
</li><li>
Some Bits:
<ul><li>
STF Books of Symbols, Expander Bits, Refinement Symbols
</li><li>
STF Wraps, CUBEs, & Connected Inclusions
</li><li>
Packed Bits & Refinement Bits
</li></ul>
</li><li>
Efficient!
</li></ul>

<h2>
STF uses Bits Effectively
</h2>

In STF: Standard Text Format, 
<ul><li>
The first bit high indicates it's a <a href="#book">STF Book</a> Symbol.
</li><li>
The second bit low indicates it's Bits.
</li><li>
If the first two bits are high then high, it's the<a href="#align"> Alignment Expander</a> for the STF Symbol.
</li><li>
If the first two bits are low then low, it's a<a href="#six"> Collection of Bits</a>.
</li><li>
The most important part of STF; if the first two bits are low then high, it's a <a href="#wrap">STF WRAP!</a>
</li></ul>
</td></tr></table>

<p>

<a name="bits"/>
<table border=10% width=100%><tr><td>
<h1>
Specific Bits in the STF Standard
</h1>
<ul><li>
1: STF Symbol
<ul><li>
11: STF Symbol in an Alignment Expander with iterator
</li><li>
10: Single STF Symbol or Expander's Bits
</li></ul>
</li><li>
0: STF Wraps & CUBEs or Bits
<ul><li>
01: STF Wraps!
</li><li>
00: Bits! STF Symbol Refinements or Collection of Bits!
</li></ul>
</li></ul>
</td></tr></table>


<p>

<a name="accurate"/>
<table border=10% width=100%><tr><td>
<h1>
Accurate Representation
</h1>
<ul><li>
Accurate Representation is critical in the presentation of Information. STF: Standard Text Format includes everything necessary to guarantee that your concepts and presentations are accurately represented!
</li></ul>
<h2>
CUBE & BALL
</h2>
<ul><li>
Every Context is provided a CUBE for its Accurate Representation. Be it a single glyph or grapheme symbol or an entire composition, each Context has a CUBE for Accurate Representation of its information.
</li><li>
Inter-association of Concepts or information is by STF Associated References. References can include the Concept of Association and can be inside the CUBE, in the CUBE's BALL, or from the Context's BALL to other STF Universal Contexts.
</li><li>
STF Contexts can be included by reference inside the Context's CUBE or referenced in the Context's CUBE's BALL.
</li><li>
STF Associated References from outside a Context are kept in the Context's BALL.
</li></ul>
<h2>
Associated Contexts
</h2>
<ul><li>
References to other Concepts in any Context use a STF Associated Reference, either in the local Context or Universal Context.
</li><li>
Concepts can be Associated to Concepts by Concepts in any STF Context.
</li></ul>
</td></tr></table>

<p>

<a name="complete"/>
<table border=10% width=100%><tr><td>
<h1>
Substantiable Completeness:
</h1>
<ul><li>
<b> STF's Books of Symbols + Refinements</b> provide indexed Standards for the complete representation of all forms of knowledge and information including simple glyphs & graphemes, toolings and formats, vocalizations & phonemes, gestures & presentations, logic & representation, ... All in this STF: STANDARD TEXT FORMAT.
</li></ul>
<h2>
Formal Completeness:
</h2>
<ul><li>
Formal Completeness means that all possible associations between concepts are exhaustively known. It is impossible to know all concepts of concepts without knowing them, therefore Substantiable Completeness determines how Information is organised into STF Books of Collections of similarly themed STF Symbols in STF: STANDARD TEXT FORMAT.
</li><li>
STF Symbols are arranged in Collections by similar theme in STF Standard Books, collated from the Community's Graph.
</li><li>
All possible Means of Representation and the STF Symbols and Refinements are derived from the unified STF Community Graph.
</li></ul>
<h2>
Process of Formalisation:
</h2>
<ul><li>
Community Graph! Collation!
</li><li>
 STF Standard Enhancements are provided each quarter year on the Seasons and intermediate enhancements are posted on the phases of the moon.
</li></ul>

<h3>
Sequence of Completeness:
</h3>
<ul><li>
Currently all forms of the STF Standard can be used for any Text or Representation, the only requirement is an Implementation. <a href="#impl">STF Standard Implementation</a> (with enhancements)
</li><li>
<ul><li>
<b>Phase 0:</b> Correct all Texts and Informations from "ascii" & "UTF"|"UCS" to STF8 Standard, build STF Community Graph of Characters & Symbols. Collate, prepare STF Books!
</li><li>
<b>Phase 1:</b> Solve Arrangement of Collections of Symbols by Associative Graph, Align Symbols in Pages of Books with STF index value.
</li><li>
<b>Phase 3:</b> Formalise STF16, STF32 & STF* Tree from aligned STF Symbols.
</li><li>
<b>Phase 4:</b> Functional Completeness!
</li></ul>
</li></ul>
</td></tr></table>




<p>

<a name="wrap"/>
<table border=10% width=100%><tr><td>
<h1>
STF WRAP: It's a Wrap!
</h1>
<h2>

</h2>
</td></tr></table>

<p>

<a name="safe"/>
<table border=10% width=100%><tr><td>
<h1>
STF is Safe
</h1>
<h2>
Get & Set of Bits in a Line of Bits.
</h2>
One single bit does it all!
Implementations can Augment
<h2>
STF is 
</h2>
<ul><li>
Inviolable: STF is the most consistent and inviolable Standard for Accurate Representation.
</li><li>
Formally Complete: All possible are included
</li><li>
Efficient: STF uses only a single iterator or switch cascade with Logical Direction of bits in STF Wraps and is the same  structure in all STF Standards: STF8 Standard, STF0 Text, and STF* of any bit scope.
</li><li>

</li></ul>
</td></tr></table>

<p>


<a name="stf0"/>
<table border=10% width=100%><tr><td>
<h1>
STF0: STF Standards in Texts
</h1>

<h1>
STF0: STF in Antiquated HTTP & IRI
</h1>
<ul><li>
Only certain combinations of bits get through HTTP and IRI (URI, URL) correctly.
</li><li>
Except for Collections of Bits [0i..63i] and some strange symbols, STF0 uses 0123456789aAbBcC for each 3i bits or 
<s>%% "percent-encoding" of bytes.</s>
</li><li>
American "ascii" #'0' is not even the correct value, and only 0..9aA..zZ_- "letters" get through IRI (URI, URL) and HTTP. These specific sequences of bits are used (mapped) only for bits of the correct value.
</li><li>
STF0 uses these antiquated patterns of misordered symbols to represent a form of STF called STF0 that matches the STF Standard.
</li><li>

</li><li>
<font color=red>
STF encodes all characters and symbols in Expanders, letter 'a' is bits 11000001 10100001 or %c1%a1. 
</li><li>
Letter '0' "zero" is bits 11000000 10110000 or %c0%b0. Anything not %% or those few !(''')() @('@.)(*~(.())) are numbers. "UTF"/"ascii" letters 0 through 9, a through z and A through Z and _- are NUMBERS 0 through 63 or 6 bits.
</font>
</li><li>
STF0 matches STF Standard including STF8.
</li></ul>
<h2>
Matching @(@)() & !()()
</h2>
<ul><li>
Both the Context @(@) and Universal Context !()() have matching information.
</li><li>
@(@)() is easier to read but relies on "DNS".
</li><li>
!()() is more Technical.
</li><li>
The @(@) Context is a subset of !()().
</li><li>
@()() and !()() are Turns & Slots (Turn)(Slot) and can be (Turn'Turn)(Slot'Slot) separated by an "air comma" ''' to get through HTTP, IRI, and "file names".
</li><li>
@(@)(<b>@(@)()</b>) is an Associated Reference between Concepts in Contexts!
</li></ul>
<h2>
@(@) Context
</h2>
<ul><li>
STF0's @(@) Context is composed of a set of Turns.
</li><li>
@(pet@house.mysite.tld)
</li><li>
The @host.tld is the DNS.
</li><li>
@(pet'toys'3@house.mysite.tld)
</li><li>
The pet'toys'3 is the Context Turns, each separated by an "air comma" ''' like a lamp-post or street-sign.
</li><li>
Because HTTP & IRI can't handle letters correctly, STF0 is packed using 4-bit 0123456789aAbBcC_- <s>%- "percent-encoding"</s> of STF (& "UTF-8") characters.
</li><li>
The unique Context is held in a single record or file of the same "file name" IRI.
</li><li>
The STF Turns can be either a letter or bits of a number.
</li><li>
This standard form must be processed correctly, 
"ascii" is a set of numbers 0..9aA..zZ_- distinct from STF 'a': . '.' is not a number.
</li><li>
Turns inside the Context .():
</li><li>
@(pet'toys'3<b>.(size)</b>@house.mysite.tld)
</li></ul>
<h2>
@(@)(@(@)(Associated Reference))
</h2>
<ul><li>
Any Concept in any Context can be associated to any Concept in any Context by any Concept! (...)
</li><li>
@(pet@house.mysite.tld)(<i>@(pet'toys'3@house.mysite.tld)(<b>likes</b>)</i>)
</li><li>
The Concept of Association can also have a structured type:
</li><li>
@(pet@house.mysite.tld)(@(pet'toys'3@house.mysite.tld)(<b>*(@(pet'thoughts'likes@house.mysite.tld))</b>))
</li><li>
Providing the Concepts of Association between any Information in any Context anywhere!
</li><li>
@(pet'toys'5th@house.mysite.tld)(@(pet'toys'3@house.mysite.tld)(isBigger))
</li><li>
or specifically to any Concept inside the Context referenced by Turns:
</li><li>
@(pet'toys'5th<b>.(size)</b>@house.mysite.tld)(@(pet'toys'3<b>.(size)</b>@house.mysite.tld)(*(@(pet'thoughts'sizes<b>.(bigger)</b>@house.mysite.tld))))
</li><li>
The Associated Reference also has a standard that includes some very simple information about the Associative Concept.
</li></ul>
<h2>
@(@)((In'Context'Turns)(Information))
</h2>
<ul><li>
Information is referenced by Turns in Slots. Information referenced by Turns is in Slots.
</li><li>
There can be any kind of Information in Slots including STF Contexts and References!
</li><li>
(index)((turn'index'turn)(value))
</li><li>
(index)((turn'index'turn)(value)'(other'turn)((more'turns)(@(ref'3r'enCeD'C0ntext)(same))))
</li></ul>
<!--
<h2>

</h2>
<ul><li>

</li><li>

</li></ul>
<h2>

</h2>
<ul><li>

</li><li>

</li></ul>
-->
<h1>
STF0: STF THROUGH Antiquated HTTP & IRI's
</h1>
<ul><li>
STF Banks use parallel matching of the structure of Turns, populating the empty Slots.
</li><li>
STF0 simply puts all the records in a CUBE @(@) or BALL @(@)() record, such as a file.
</li><li>
STF0 is easy to handle, References and Associatives are simply appended to the BALL "file", and the STF Context CUBE is appended as well!
</li></ul>
<h2>
STF0 
</h2>
<ul><li>
The STF Context's data is in @(mY'Context'4@host.tld) and is a collection of lines with Turns and Slots and Information.
</li><li>
@(mY'Context'4@host.tld)
</li><li>
The Context can have its Associated References inside as well, @(you@your.tld)(saw) throughout the Text.
</li><li>
References from outside the Context all go in the BALL "file" @(@)()
</li><li>
@(mY'Context'4@host.tld)<b>()</b>
</li><li>
The STF Implementation will typically GET the Context "file", check if there is a ~() infrastructure indicator like ~(next)(@(@)) and then prioritise getting that next in sequence or everyone's references that are in @(@)() the BALL.
</li><li>
Time Slices can be used in both the Context's re-vision (it is always better to make another new one so you can keep all the variations) and in spreading Associative References across bins in time.
</li><li>
When a @(@)() BALL "file" is split in times, it keeps a reference ~(next)(@(@)()) in each, and puts a ~() reference to it in @(@)(). ~(prev), ~(part) & ~(chop) 
</li><li>
These ~() infrastructure symbols match STF8 and are four-letter-NUMBERS!
</li><li>
All of the Context data goes in one record, all of the Associative References are appended in the other!
</li></ul>

<h2>
STF0 HOST "Infrastructure"
</h2>
<ul><li>
All STF0 requires is the append a record or file, access by "name", and provide time & size info (like HTTP HEAD).
</li><li>
STF0 can be single packets or a structured transport like HTTP (HTTP may or may not work correctly.)
</li><li>
The correct implementation is STF0 @(@) or @(@)() references.
</li></ul>

<h2>
STF0 via HTTP
</h2>
<ul><li>
HTTP is not preferable, but 
STF0 via HTTP prefers 
</li><li>
GET @(@) and @(@)() "files" by "name"
Associative References are posted by including it @(x@x)(@(my'ref@my.tld)(connects)), and the host appends that line in the BALL "file" @(x@x)() but the response will be the confirmation of the line or a 'FAILCHOPPOSTLINE' indicating it should use HTTP POST ?LINE= because the HTTP server cut off the line erroneously. If the host does not include the Associative References locally, it can say TELL@(@otherhost.tld) and the STF Implementation should tell it there instead. (same as ~(tell)(@(@)) Declared in the Context. (multiple'tells))
</li><li>
The HTTP service should allow HEAD,GET,POST,RESUME functions, HEAD and RESUME get new increments of the file, GET should automatically transfer the request to append the Associated Reference if the file does not exist (.htaccess), and POST compensates for design flaws of HTTP (request length) or when the script is not automatic.
</li></ul>

<h2>
STF0 via HTTP Parts
</h2>
<ul><li>
It is preferable that you use your own custom server that handles packets and bits correctly, otherwise you can use something like these examples for common HTTP "server"
</li><li>
Minimal validation of STF0 References tests if the  ()'s are matched, then selects if you want extra sub-context Turns separated (for large texts in one STF) or everything in one @(@)(), then checks if the Context actually exists, and puts the Reference in the matching BALL "file" @(@)() with append and a \n. 
</li><li>
Appending lines into your context should require some form of auth. References must be appended.
</li><li>
Associated References are simply posted in their full form, the infrastructure needs to append them into the correct "file".
</li><li>

</li></ul>

<h3>
STF0 via HTTP .htaccess
</h3>
<ul><li>
Redirecting the Associative Reference into the BALL "file" using common ".htaccess" and HTTP GET
</li><li>
.htaccess<br>
<small><pre>
&lt;ifmodule mod_rewrite.c&gt;
RewriteEngine on
RewriteCond %{REQUEST_FILENAME} !-f
RewriteCond %{REQUEST_FILENAME} !-d
RewriteRule . ./stf0.php
&lt;/ifmodule&gt;
</pre></small>
</li><li>
The result is GET /@(My'con'tExt@my.host.tld)(@(their'c0ntext@their.tld)(the'associative))
</li></ul>

<h3>
STF0 via HTTP stf0.php
</h3>
<ul><li>
The minimal functions of the STF0 service are to take the GET and POST and send the record "file". 
</li><li>
If the file exists, HTTP GET should have sent it.
</li><li>
You can put the data somewhere else, as long as the append is correct and changed time & size are told correctly. the GET /@(@host.tld) or GET /@(@) should indicate if your infrastructure implementation uses some other interface (including ~(tell)(@(@http://other.host.tld/fail.php?trystfo=)) where the "http:" is properly %%'d
</li><li>
Here's the simple PHP that might work.
</li><li>
stf0.php<br>
<small><pre>
&lt;?php


$PutEverythingInOneFile = 0;
$UseSubContextBALLs = 0;
$UseBALLs = 1;
$SplitBallOnTime = 0;
$auth = "true"; // ...?

// The HTTP and "Web Browser" have a lot of problems.
header("Access-Control-Allow-Origin: *");
header("stf: 0");

// First, recover the @(@)() from the HTTP server.

$request_uri = explode('/', trim($_SERVER['REQUEST_URI'], '/'));
$script_name = explode('/', trim($_SERVER['SCRIPT_NAME'], '/'));
$parts = array_diff_assoc($request_uri, $script_name);

if (empty($parts)) {
// / send html body onload("@(@)" or a Context of your preference + script or 403
echo '...';
exit();
}

$path = implode('/', $parts); 

// Check if there is a ? 

if (($position = strpos($path, '?')) !== FALSE)
{ 
$path = substr($path, 0, $position);
$q =  substr($path,$position,strlen($path));//?

// $q is the ?=, extract auth + new file name and append content, or extract long line

// $line =

}

$line = $path;

// $line is the @(@)(@(@)()) Associated Reference

// Make sure it starts correctly.
if ( ($line[0] == '@') || ($line[0] == '!') )
{

// Test if it's actually a @(@)(@(@)()) (with times)

if ( ($line[1] == '(') || ($line[5] == '(') || ($line[7] == '(') )
{

// Minimal Validate matching ()'s by counting
// Extract the Context "file name" including %%s
// Put the STF0 in the BALL file ().
// option of \n\n\n for fast alignment.
// if the @(@)() is chopped up by HTTP  FAILCHOPPOSTLINE.

// very wrong ;)
$f = substr($line, 0, strpos($line, ')')) . ")()";

// if (PutEverythingInOneFile)
// $f = "@(@)()";

$fh = fopen($f,'a') or die("stfu");
fwrite($fh, "\n" . $line . "\n");
fclose($fh);

echo $f . "\n"; 

}// @time(
}// @

 exit();

?&gt;

</pre></small>
</li><li>
</li></ul>

...
</li><li>
</li><li>
</li></ul>
</td></tr></table>

<p>

<a name="stf*"/><a name="stf8"/>
<table border=10% width=100%><tr><td>
<h1>
STF Standard: STF* & STF8
</h1>
<ul><li>
STF Standard Text Format 
</li><li>
Single pattern optimised for STF8.
</li><li>
STF Symbol Books include ALL possible Representations of Information, Characters of Text, Layout & Formatting, Tooling and Presentation, plus Refinement Bits!

</li><li>
<small>STF* allows mixed size blocks by using a pulse-driven indicator, symbols 10000001 or 11000001 then a Control Wrap mutually re-affirming the scope with the number in bits: 00000111 for 7i "8-bit" and the closing Control Wrap.</small>
</li></ul>
</td></tr><tr><td>
<h1>
1 : Expander
</h1>
STF Books of Indexed Symbols are packed in Expanders. The STF8 index value is packed in an Alignment Expander and some Continuing Expander Blocks.
<ul><li>
STF Books include all Character Symbols, Formatting, Layout & Control, Phonemes & Graphemes, 2D 3D & 4D Means of Representation, Gestures and Vocalizations, and 5D Tooling, Logic, Infrastructures & Implementations...
</li><li>
STF Symbols can be followed by a Refinement, either a Collection of Bits or an Inclusion Wrap or STF Refinement Symbol that has additional specifics. Larger "dictionary" refinements on sequences of symbols is the same as an Inclusion of the named/index Turns in the Concept's Declaration.
</li><li>
<small>STF includes all of UCS, "UTF-8", GB18030, UCS, etc in one STF Book. All UTF + "ascii" are expanded in STF Book #0.</small>
</li></ul>
<h2>
11 : Expander Alignment & Iterator
</h2>
Bit Iterator of number of Continuing Expanders, plus some STF index value bits.
<h3>
STF8: 11 : 0xxxxx or 10xxxx to 111110 or 111111
</h3>
<ul><li>
This Alignment Expander + One Block of Continuing Expander Bits per Indicated Iterator.
</li><li>
This 1 + 10 to 1111110 or 1111111 (Count 1 to 8 total) Blocks of Expander bits, then a 0 and bits. Remaining x bits: leading bits of STF index value. 
</li></ul>
<h3>
STF*: 11 : 0x or 10x to 1N0x or high filled to scope
</h3>
<ul><li>
This Alignment Expander + One Block of Continuing Expander Bits per Indicated Iterator.
</li><li>
This Expander + N Blocks of Continuing Expander Bits in Arbitrary STF* Expander, then a 0 (or high bit filled scope of Block) and bits. Remaining x bits: leading bits of STF index value.
</li></ul>
<h2>
10 :  <i>Single Value Expander</i> or Continuing Expander's Bits
</h2>
A simple STF index value in 10:, or part of a continuing sequence with an Alignment Expander.
<h3>
STF8: 10 : xxxxxx : Six Expander Bits 
</h3>
<ul><li>The [0i..5i] bits of the Expander
<!--
<small>***No 10xxxxxx Singles in STF8***</small>
-->
</li></ul>
<h3>
STF*: 10 : xxxxxx_______x : Arbitrary Expander Bits or <b>Single Value</b>
</h3>
<ul><li>
<b>Single Value when not included in an Alignment Expander's Continuing Sequence</b>.
</li><li>
Continuing Sequence of Expander's Bits packed in ( scope - 2 bit: 10 ) Blocks to Alignment Expander's Iterations.
</li><li>
</li></ul>
</td></tr><tr><td>
<h1>
01 : STF Control Symbol
</h1>
<h2>
01: 1 : STF WRAP or Connected Inclusion
</h2>
Wraps of Information, Slots & Turns with named indexes, STF Context References, everything in STF Books...
<h3>
01: 1 : 1 : WRAP ON
</h3>
<h3>
01: 1 : 0 : WRAP OFF
</h3>
It's A WRAP!
<ul><li>
STF Wraps include Symbols in STF Books with Refinement Modifier Values, Collections of Bits, Complexities of more Wraps included inside! Named and Indexed Turns & Sets in Slots, Parts & Wholes, References, and the STF Associative Reference!
</li><li>
see <a href="#wrap">STF Wraps</a>
</li></ul>
<h2>
01 : 0 : STF Inclusions
</h2>
STF Inclusions and Technical Inclusions provide all the data + Information needed in the standard.
<h3>
01: 0 : 1 : Connectedness ON
</h3>
<h3>
01: 0 : 0 : Connectedness OFF
</h3>
Connected Technical Inclusion or Connected Infrastructures
<ul>
<li>
Technical Inclusions with LINEs of Bits & Infrastructures.
</li><li>
see <a href="#incl">STF Inclusions</a>
</li></ul>
</td></tr><tr><td>
<h1>
00 : Packed Bits
</h1>
<h2>
00 : xxxxxx... : Collection of Bits
</h2>
<h3>
STF8: 00 : xxxxxx : Six Packed Bits
</h3>
<h3>
STF*: 00 : xxxxxx_______x : Arbitrary Packed Bits
</h3>
( scope - 2 bit: 00 ) + ___ bits. Similar to 10: single index value.
</td></tr><tr><td>
<small>
<ul><li>
All bits are Leading highest first "msb" or "network order".
</li><li>
Expanders can be packed to tightest or a specific size of block sequences.
</li><li>
Wrap includes a "page" indicator, the entire Wrap can be in one STF Book & Page prefix.
</li><li>
No bits not in this.
</li><li>
</li></ul>
</small>
</td></tr></table>


<p>









<a name="impl"/>
<table border=10% width=100%><tr><td>
<h1>
Get & Set Bits: STF Implementations
</h1>
<ul><li>
STF Implementation does exactly one thing, the Get & Set of Bits in LINEs.
</li><li>
The STF Standard Implementation provides the Context's CUBE and BALL and some infrastructures.
</li><li>
Implementations can include things like pixels on screens or other Augmented Implementations.
</li></ul>

<h2>
Offsets of Bits, Containers, Collections & Spreads, Low & High Align
</h2>
<ul><li>
The minimal function is the Get & Set of Bits in Containers.
</li><li>
The first to last is index offset of range of bits in the container.
</li><li>
</li></ul>

<h3>
Offsets of Bits, Range of Indexes
</h3>
<ul><li>
The minimal function is the Get & Set of Bits in Containers.
</li><li>
In a container, the bits are in LINE.
</li><li>
STF minimal infrastructure Gets a bit in Line and Sets a bit in Line.
</li><li>
The range of bits can be any end to end length an is sometimes called "copy" bits.
</li></ul>
<h3>
Bits in Containers
</h3>
<ul><li>
Bits in LINEs are in containers of the same size or bigger and the offset can be referenced by index multiples as Declared Collections of Bits.
</li><li>
</li></ul>

<h3>
Bits in Wraps, Turns & Slots, Collections of Bits & Collections
</h3>
<ul><li>
Wraps of bits, in LINEs in containers, can be referenced by their index in Turns or Slots of the tree.
</li><li>
Collections of Bits can be Declared as a bit, count of multiple Bits, and multiples of multiples by Declaring them in Wraps.
</li><li>
Structured collections of bits are referenced by Turns or Slots in tree.
</li><li>
Bits can be Get or Set by an index of container, mask of the container, or range of patterns of structure of bits in collections or collections of collections.
</li><li>
A mask to select the bits or the named or indexed Turns and Slots can be included, it is collections of bits or collections of collections.
</li><li>
Can to select the high (leading) or low aligned in Get or Set to container in LINE.
</li><li>
Collections of bits can be spread into arbitrary size containers, such as the high bit of colors or the leading bits of a field by Declaring the Collection of Collections that include Bits or Containers, then indicating the Slot or index they go in.
</li><li>
Spreading ranges of Collections of colors from a bit each to the high bit in color channels.
</li><li>
</li><li>
</li><li>
</li><li>
</li><li>

</li></ul>
<h2>
LINE & BANK, Hot Lines & "Cache"
</h2>
<ul><li>
LINEs of Bits 
</li><li>
</li><li>
And some requests for the Infrastructure to check the currency of the STFs in the Bank.
</li><li>
</li></ul>

<h2>
STF CUBE & BALL
</h2>
<ul><li>
A "cube" is provided for the Accurate Representation. A 2D cube can has indicators of color. Cubes go in cubes, where you put stuff like letters. Ball is how stuff outside is related. Implementation provides cube. Cube can flow.
</li></ul>

<h2>
STF FLOW
</h2>
<ul><li>
FLOW is a very simple set of references in SLOTs that match the named or indexed Slot with turns. 
</li><li>
have matching ("named") conditions. Each variate 
</li><li>
Each has a reference to another flow. Declared Collections, Bits, and Wraps included.
</li><li>
</li><li>
FLOW can have very simple cycles. Using a test condition and Get & Set Bits provides all logic and process flow to your Collection of Bits.
</li></ul>

<h2>
Table Basher "true"
</h2>
<ul><li>
STF provides a minimal collection of true, with some index values in slots and turns that go with Get Set Bits and flow.
</li><li>
Tree bits in elementary table
</li><li>
Use to build Collections of Bits like ADD with values 0 to 9 in 4 bits, etc.
</li></ul>


<h2>
Augmented Infrastructures
</h2>
<ul><li>
Implementations can make available other LINEs or FLOWs, like pixels or communication lines, and provide valid specific functions like add-cary of a fixed bit scope to Set Bits. 
</li></ul>
<h2>
Inviolable
</h2>
<ul><li>
STF Declares only one way to Get & Set Bits. It is impossible to do anything else.
</li></ul>
</td></tr></table>

<p>

<a name="one"/>
<table border=10% width=100%><tr><td>
<h1>

</h1>
<ul><li>
</li></ul>
</td></tr></table>



<p>

<a name="one"/>
<table border=10% width=100%><tr><td>
<h1>

</h1>
<ul><li>
</li></ul>
</td></tr></table>

<p>

<a name="one"/>
<table border=10% width=100%><tr><td>
<h1>

</h1>
<ul><li>
</li></ul>
</td></tr></table>


<p>

<a name="incl"/>
<table border=10% width=100%><tr><td>
<h1>
STF Inclusions: Technical Inclusions
</h1>
<ul><li>
</li></ul>

<!-- STF8: c0 & c1 in STF Book #0 are used to indicate 0x00. -->
</td></tr></table>

<p>
The Prior draft of this text: <a href="index0.html">index0.html</a>
<Br>
The prior Prior draft of this text: <a href="index1.html">index1.html</a>
<Br>
Outdated <a href="index2.html">index2.html</a>
</body>
</html>
